From e6ca5f8935c53edc64d8b41ea5ed3f43c4212552 Mon Sep 17 00:00:00 2001
From: Raul Metsma <raul@metsma.ee>
Date: Mon, 16 Sep 2024 15:23:00 +0300
Subject: [PATCH] EstEID 2025

Signed-off-by: Raul Metsma <raul@metsma.ee>
---
 .gitignore                        |   1 +
 doc/files/files.html              |   1 +
 doc/files/opensc.conf.5.xml.in    |   1 +
 src/libopensc/Makefile.am         |   4 +-
 src/libopensc/Makefile.mak        |   4 +-
 src/libopensc/card-esteid2025.c   | 229 ++++++++++++++++++++++++++++++
 src/libopensc/cards.h             |  10 +-
 src/libopensc/ctx.c               |   3 +-
 src/libopensc/pkcs15-esteid2025.c | 210 +++++++++++++++++++++++++++
 src/libopensc/pkcs15-syn.c        |   1 +
 src/libopensc/pkcs15-syn.h        |   1 +
 src/libopensc/pkcs15.c            |   1 +
 12 files changed, 457 insertions(+), 9 deletions(-)
 create mode 100644 src/libopensc/card-esteid2025.c
 create mode 100644 src/libopensc/pkcs15-esteid2025.c

Index: opensc-0.26.1/.gitignore
===================================================================
--- opensc-0.26.1.orig/.gitignore
+++ opensc-0.26.1/.gitignore
@@ -155,3 +155,4 @@ src/tests/fuzzing/fuzz_scconf_parse_stri
 version.m4.ci
 openssl_arm64
 openssl_bin
+openpace_bin
Index: opensc-0.26.1/doc/files/files.html
===================================================================
--- opensc-0.26.1.orig/doc/files/files.html
+++ opensc-0.26.1/doc/files/files.html
@@ -805,6 +805,7 @@ app <em class="replaceable"><code>applic
 							<code class="literal">dnie</code>,
 							<code class="literal">edo</code>,
 							<code class="literal">esteid2018</code>,
+							<code class="literal">esteid2025</code>,
 							<code class="literal">flex</code> (deactivated driver),
 							<code class="literal">cyberflex</code> (deactivated driver),
 							<code class="literal">gemsafeV1</code>,
Index: opensc-0.26.1/doc/files/opensc.conf.5.xml.in
===================================================================
--- opensc-0.26.1.orig/doc/files/opensc.conf.5.xml.in
+++ opensc-0.26.1/doc/files/opensc.conf.5.xml.in
@@ -1248,6 +1248,7 @@ app <replaceable>application</replaceabl
 							<literal>dnie</literal>,
 							<literal>edo</literal>,
 							<literal>esteid2018</literal>,
+							<literal>esteid2025</literal>,
 							<literal>flex</literal> (deactivated driver),
 							<literal>cyberflex</literal> (deactivated driver),
 							<literal>gemsafeV1</literal>,
Index: opensc-0.26.1/src/libopensc/Makefile.am
===================================================================
--- opensc-0.26.1.orig/src/libopensc/Makefile.am
+++ opensc-0.26.1/src/libopensc/Makefile.am
@@ -49,12 +49,12 @@ libopensc_la_SOURCES_BASE = \
 	card-iasecc.c iasecc-sdo.c iasecc-sm.c card-sc-hsm.c \
 	card-dnie.c cwa14890.c cwa-dnie.c \
 	card-isoApplet.c card-masktech.c card-gids.c card-jpki.c \
-	card-npa.c card-esteid2018.c card-idprime.c \
+	card-npa.c card-esteid2018.c card-esteid2025.c card-idprime.c \
 	card-edo.c card-nqApplet.c card-skeid.c card-eoi.c card-dtrust.c \
 	\
 	pkcs15-openpgp.c pkcs15-starcert.c pkcs15-cardos.c pkcs15-tcos.c \
 	pkcs15-actalis.c pkcs15-atrust-acos.c pkcs15-tccardos.c pkcs15-piv.c \
-	pkcs15-cac.c pkcs15-esinit.c pkcs15-pteid.c \
+	pkcs15-cac.c pkcs15-esinit.c pkcs15-pteid.c pkcs15-esteid2025.c \
 	pkcs15-oberthur.c pkcs15-itacns.c pkcs15-gemsafeV1.c pkcs15-sc-hsm.c \
 	pkcs15-coolkey.c pkcs15-din-66291.c pkcs15-idprime.c pkcs15-nqApplet.c \
 	pkcs15-dnie.c pkcs15-gids.c pkcs15-iasecc.c pkcs15-jpki.c pkcs15-esteid2018.c \
Index: opensc-0.26.1/src/libopensc/Makefile.mak
===================================================================
--- opensc-0.26.1.orig/src/libopensc/Makefile.mak
+++ opensc-0.26.1/src/libopensc/Makefile.mak
@@ -27,7 +27,7 @@ OBJECTS			= \
 	card-iasecc.obj iasecc-sdo.obj iasecc-sm.obj cwa-dnie.obj cwa14890.obj \
 	card-sc-hsm.obj card-dnie.obj card-isoApplet.obj pkcs15-coolkey.obj \
 	card-masktech.obj card-gids.obj card-jpki.obj \
-	card-npa.obj card-esteid2018.obj card-idprime.obj \
+	card-npa.obj card-esteid2018.obj card-esteid2025.obj card-idprime.obj \
 	card-edo.obj card-nqApplet.obj card-skeid.obj card-eoi.obj card-dtrust.obj \
 	\
 	pkcs15-openpgp.obj pkcs15-starcert.obj pkcs15-cardos.obj pkcs15-tcos.obj \
@@ -35,7 +35,7 @@ OBJECTS			= \
 	pkcs15-cac.obj pkcs15-esinit.obj pkcs15-pteid.obj pkcs15-din-66291.obj \
 	pkcs15-oberthur.obj pkcs15-itacns.obj pkcs15-gemsafeV1.obj pkcs15-sc-hsm.obj \
 	pkcs15-dnie.obj pkcs15-gids.obj pkcs15-iasecc.obj pkcs15-jpki.obj \
-	pkcs15-esteid2018.obj pkcs15-idprime.obj pkcs15-nqApplet.obj \
+	pkcs15-esteid2018.obj pkcs15-esteid2025.obj pkcs15-idprime.obj pkcs15-nqApplet.obj \
 	pkcs15-starcos-esign.obj pkcs15-skeid.obj pkcs15-eoi.obj pkcs15-dtrust.obj \
 	compression.obj sm.obj aux-data.obj \
 	$(TOPDIR)\win32\versioninfo.res
Index: opensc-0.26.1/src/libopensc/card-esteid2025.c
===================================================================
--- /dev/null
+++ opensc-0.26.1/src/libopensc/card-esteid2025.c
@@ -0,0 +1,229 @@
+/*
+ * Driver for EstEID card issued from December 2025.
+ *
+ * Copyright (C) 2025, Raul Metsma <raul@metsma.ee>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+
+#include "asn1.h"
+#include "gp.h"
+#include "internal.h"
+
+#define SIGNATURE_PAYLOAD_SIZE 0x30
+
+static const struct sc_atr_table esteid_atrs[] = {
+		{"3b:ff:96:00:00:80:31:fe:43:80:31:b8:53:65:49:44:64:b0:85:05:10:12:23:3f:1d", NULL, "EstEID 2025", SC_CARD_TYPE_ESTEID_2025, 0, NULL},
+		{NULL,									 NULL, NULL,	   0,			      0, NULL}
+};
+
+static const struct sc_aid THALES_AID = {
+		{0xA0, 0x00, 0x00, 0x00, 0x63, 0x50, 0x4B, 0x43, 0x53, 0x2D, 0x31, 0x35},
+		12
+};
+
+static const struct sc_card_operations *iso_ops = NULL;
+static struct sc_card_operations esteid_ops;
+
+static struct sc_card_driver esteid2025_driver = {"EstEID 2025", "esteid2025", &esteid_ops, NULL, 0, NULL};
+
+#define SC_TRANSMIT_TEST_RET(card, apdu, text) \
+	do { \
+		LOG_TEST_RET(card->ctx, sc_transmit_apdu(card, &apdu), "APDU transmit failed"); \
+		LOG_TEST_RET(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2), text); \
+	} while (0)
+
+static int
+esteid_match_card(sc_card_t *card)
+{
+	int i = _sc_match_atr(card, esteid_atrs, &card->type);
+
+	if (i >= 0 && gp_select_aid(card, &THALES_AID) == SC_SUCCESS) {
+		card->name = esteid_atrs[i].name;
+		return 1;
+	}
+	return 0;
+}
+
+static int
+esteid_select_file(struct sc_card *card, const struct sc_path *in_path, struct sc_file **file_out)
+{
+	u8 resp[SC_MAX_APDU_RESP_SIZE];
+	size_t resplen = sizeof(resp);
+	int r;
+	struct sc_file *file = NULL;
+	struct sc_apdu apdu;
+
+	LOG_FUNC_CALLED(card->ctx);
+
+	// Only support full paths
+	if (in_path->type != SC_PATH_TYPE_PATH) {
+		LOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);
+	}
+
+	sc_format_apdu_ex(&apdu, card->cla, 0xA4, 0x08, 0x04, in_path->value, in_path->len, resp, resplen);
+	SC_TRANSMIT_TEST_RET(card, apdu, "SELECT failed");
+	if (file_out != NULL) {
+		file = sc_file_new();
+		if (file == NULL)
+			LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
+		r = iso_ops->process_fci(card, file, resp, resplen);
+		if (r != SC_SUCCESS) {
+			sc_file_free(file);
+		}
+		LOG_TEST_RET(card->ctx, r, "Process fci failed");
+		*file_out = file;
+	}
+	LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);
+}
+
+static int
+esteid_set_security_env(sc_card_t *card, const sc_security_env_t *env, int se_num)
+{
+	struct sc_apdu apdu;
+	u8 cse_crt_sig[] = {0x80, 0x01, 0x54, 0x84, 0x01, 0x00};
+	u8 cse_crt_der[] = {0x84, 0x01, 0x00};
+
+	LOG_FUNC_CALLED(card->ctx);
+
+	if (env == NULL || env->key_ref_len != 1)
+		LOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);
+
+	sc_log(card->ctx, "algo: %lu operation: %d keyref: %d", env->algorithm, env->operation, env->key_ref[0]);
+
+	if (env->algorithm == SC_ALGORITHM_EC && env->operation == SC_SEC_OPERATION_SIGN) {
+		cse_crt_sig[5] = env->key_ref[0];
+		sc_format_apdu_ex(&apdu, 0x00, 0x22, 0x41, 0xB6, cse_crt_sig, sizeof(cse_crt_sig), NULL, 0);
+	} else if (env->algorithm == SC_ALGORITHM_EC && env->operation == SC_SEC_OPERATION_DERIVE) {
+		cse_crt_der[2] = env->key_ref[0];
+		sc_format_apdu_ex(&apdu, 0x00, 0x22, 0x41, 0xB8, cse_crt_der, sizeof(cse_crt_der), NULL, 0);
+	} else {
+		LOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);
+	}
+	SC_TRANSMIT_TEST_RET(card, apdu, "SET SECURITY ENV failed");
+
+	LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);
+}
+
+static int
+esteid_compute_signature(sc_card_t *card, const u8 *data, size_t datalen, u8 *out, size_t outlen)
+{
+	struct sc_apdu apdu;
+	u8 sbuf[SIGNATURE_PAYLOAD_SIZE + 2] = {0x90, SIGNATURE_PAYLOAD_SIZE};
+	size_t le = MIN(SC_MAX_APDU_RESP_SIZE, MIN(SIGNATURE_PAYLOAD_SIZE * 2, outlen));
+
+	LOG_FUNC_CALLED(card->ctx);
+	if (data == NULL || out == NULL || datalen > SIGNATURE_PAYLOAD_SIZE)
+		LOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);
+
+	// left-pad if necessary
+	memcpy(&sbuf[SIGNATURE_PAYLOAD_SIZE + 2 - datalen], data, MIN(datalen, SIGNATURE_PAYLOAD_SIZE));
+	datalen = SIGNATURE_PAYLOAD_SIZE + 2;
+
+	sc_format_apdu_ex(&apdu, 0x00, 0x2A, 0x90, 0xA0, sbuf, datalen, NULL, 0);
+	SC_TRANSMIT_TEST_RET(card, apdu, "PSO Set Hash failed");
+
+	sc_format_apdu_ex(&apdu, 0x00, 0x2A, 0x9E, 0x9A, NULL, 0, out, le);
+	SC_TRANSMIT_TEST_RET(card, apdu, "PSO Compute Digital Signature failed");
+
+	LOG_FUNC_RETURN(card->ctx, (int)apdu.resplen);
+}
+
+static int
+esteid_get_pin_remaining_tries(sc_card_t *card, int pin_reference)
+{
+	const u8 get_pin_info[] = {0xA0, 0x03, 0x83, 0x01, pin_reference};
+	struct sc_apdu apdu;
+	u8 apdu_resp[SC_MAX_APDU_RESP_SIZE];
+	size_t taglen;
+	LOG_FUNC_CALLED(card->ctx);
+
+	sc_format_apdu_ex(&apdu, 0x00, 0xCB, 0x00, 0xFF, get_pin_info, sizeof(get_pin_info), apdu_resp, sizeof(apdu_resp));
+	SC_TRANSMIT_TEST_RET(card, apdu, "GET DATA(pin info) failed");
+	if (apdu.resplen < 3 || apdu.resp[0] != 0xA0)
+		LOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);
+
+	const u8 *tag = sc_asn1_find_tag(card->ctx, apdu_resp + 2, apdu.resplen - 2, 0xDF21, &taglen);
+	if (tag == NULL || taglen == 0)
+		LOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);
+	return tag[0];
+}
+
+static int
+esteid_pin_cmd(sc_card_t *card, struct sc_pin_cmd_data *data, int *tries_left)
+{
+	int r;
+	LOG_FUNC_CALLED(card->ctx);
+	sc_log(card->ctx, "PIN CMD is %d", data->cmd);
+	if (data->cmd == SC_PIN_CMD_GET_INFO) {
+		sc_log(card->ctx, "SC_PIN_CMD_GET_INFO for %d", data->pin_reference);
+		r = esteid_get_pin_remaining_tries(card, data->pin_reference);
+		LOG_TEST_RET(card->ctx, r, "GET DATA(pin info) failed");
+
+		data->pin1.tries_left = r;
+		data->pin1.max_tries = -1; // "no support, which means the one set in PKCS#15 emulation sticks
+		data->pin1.logged_in = SC_PIN_STATE_UNKNOWN;
+		LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);
+	}
+
+	LOG_FUNC_RETURN(card->ctx, iso_ops->pin_cmd(card, data, tries_left));
+}
+
+static int
+esteid_init(sc_card_t *card)
+{
+	unsigned long flags, ext_flags;
+
+	flags = SC_ALGORITHM_ECDSA_RAW | SC_ALGORITHM_ECDH_CDH_RAW | SC_ALGORITHM_ECDSA_HASH_NONE;
+	ext_flags = SC_ALGORITHM_EXT_EC_NAMEDCURVE | SC_ALGORITHM_EXT_EC_UNCOMPRESES;
+
+	_sc_card_add_ec_alg(card, 384, flags, ext_flags, NULL);
+
+	LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);
+}
+
+static int
+esteid_logout(sc_card_t *card)
+{
+	return gp_select_aid(card, &THALES_AID);
+}
+
+struct sc_card_driver *
+sc_get_esteid2025_driver(void)
+{
+	struct sc_card_driver *iso_drv = sc_get_iso7816_driver();
+
+	if (iso_ops == NULL)
+		iso_ops = iso_drv->ops;
+
+	esteid_ops = *iso_drv->ops;
+	esteid_ops.match_card = esteid_match_card;
+	esteid_ops.init = esteid_init;
+
+	esteid_ops.select_file = esteid_select_file;
+
+	esteid_ops.set_security_env = esteid_set_security_env;
+	esteid_ops.compute_signature = esteid_compute_signature;
+	esteid_ops.pin_cmd = esteid_pin_cmd;
+	esteid_ops.logout = esteid_logout;
+
+	return &esteid2025_driver;
+}
Index: opensc-0.26.1/src/libopensc/cards.h
===================================================================
--- opensc-0.26.1.orig/src/libopensc/cards.h
+++ opensc-0.26.1/src/libopensc/cards.h
@@ -100,7 +100,7 @@ enum {
 	SC_CARD_TYPE_OBERTHUR_32K_BIO,
 	SC_CARD_TYPE_OBERTHUR_64K,
 	/* Oberthur 'COSMO v7' with applet 'AuthentIC v3.2' */
-        SC_CARD_TYPE_OBERTHUR_AUTHENTIC_3_2 = 11100,
+	SC_CARD_TYPE_OBERTHUR_AUTHENTIC_3_2 = 11100,
 
 	/* belpic driver */
 	SC_CARD_TYPE_BELPIC_BASE = 12000,
@@ -191,9 +191,9 @@ enum {
 
 	/* Spanish DNIe card */
 	SC_CARD_TYPE_DNIE_BASE = 27000,
-	SC_CARD_TYPE_DNIE_BLANK, /* ATR LC byte: 00 */
-	SC_CARD_TYPE_DNIE_ADMIN, /* ATR LC byte: 01 */
-	SC_CARD_TYPE_DNIE_USER,  /* ATR LC byte: 03 */
+	SC_CARD_TYPE_DNIE_BLANK,      /* ATR LC byte: 00 */
+	SC_CARD_TYPE_DNIE_ADMIN,      /* ATR LC byte: 01 */
+	SC_CARD_TYPE_DNIE_USER,	      /* ATR LC byte: 03 */
 	SC_CARD_TYPE_DNIE_TERMINATED, /* ATR LC byte: 0F */
 
 	/* JavaCards with isoApplet */
@@ -231,6 +231,7 @@ enum {
 
 	/* EstEID cards */
 	SC_CARD_TYPE_ESTEID_2018 = 35000,
+	SC_CARD_TYPE_ESTEID_2025,
 
 	/* Rutoken cards */
 	SC_CARD_TYPE_RUTOKENS = 36000,
@@ -305,6 +306,7 @@ extern sc_card_driver_t *sc_get_cac_driv
 extern sc_card_driver_t *sc_get_cac1_driver(void);
 extern sc_card_driver_t *sc_get_npa_driver(void);
 extern sc_card_driver_t *sc_get_esteid2018_driver(void);
+extern sc_card_driver_t *sc_get_esteid2025_driver(void);
 extern sc_card_driver_t *sc_get_idprime_driver(void);
 extern sc_card_driver_t *sc_get_edo_driver(void);
 extern sc_card_driver_t *sc_get_nqApplet_driver(void);
Index: opensc-0.26.1/src/libopensc/ctx.c
===================================================================
--- opensc-0.26.1.orig/src/libopensc/ctx.c
+++ opensc-0.26.1/src/libopensc/ctx.c
@@ -134,7 +134,6 @@ static const struct _sc_driver_entry int
 	{ "dnie",       (void *(*)(void)) sc_get_dnie_driver },
 #endif
 	{ "masktech",	(void *(*)(void)) sc_get_masktech_driver },
-	{ "esteid2018",	(void *(*)(void)) sc_get_esteid2018_driver },
 	{ "idprime",	(void *(*)(void)) sc_get_idprime_driver },
 #if defined(ENABLE_SM) && defined(ENABLE_OPENPACE)
 	{ "edo",        (void *(*)(void)) sc_get_edo_driver },
@@ -142,6 +141,8 @@ static const struct _sc_driver_entry int
 
 /* Here should be placed drivers that need some APDU transactions in the
  * driver's `match_card()` function. */
+	{ "esteid2018",	(void *(*)(void)) sc_get_esteid2018_driver },
+	{ "esteid2025",	(void *(*)(void)) sc_get_esteid2025_driver },
 	{ "coolkey",	(void *(*)(void)) sc_get_coolkey_driver },
 	/* MUSCLE card applet returns 9000 on whatever AID is selected, see
 	 * https://github.com/JavaCardOS/MuscleCard-Applet/blob/master/musclecard/src/com/musclecard/CardEdge/CardEdge.java#L326
Index: opensc-0.26.1/src/libopensc/pkcs15-esteid2025.c
===================================================================
--- /dev/null
+++ opensc-0.26.1/src/libopensc/pkcs15-esteid2025.c
@@ -0,0 +1,210 @@
+/*
+ * PKCS15 emulation layer for EstEID card issued from December 2025.
+ *
+ * Copyright (C) 2025, Raul Metsma <raul@metsma.ee>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <ctype.h>
+#include <stdlib.h>
+
+#include "common/compat_strlcpy.h"
+
+#include "internal.h"
+#include "opensc.h"
+#include "pkcs15.h"
+
+static int
+sc_pkcs15emu_esteid2025_init(sc_pkcs15_card_t *p15card)
+{
+	sc_card_t *card = p15card->card;
+	u8 *buff;
+	int r, i;
+	size_t field_length = 0, buflen = 9, j;
+	sc_path_t tmppath;
+	static const u8 prkey_id[2] = {0x01, 0x02};
+
+	set_string(&p15card->tokeninfo->label, "ID-kaart");
+	set_string(&p15card->tokeninfo->manufacturer_id, "Thales");
+
+	buff = malloc(buflen + 1);
+	if (!buff)
+		LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
+
+	/* Read document number to be used as serial */
+	sc_format_path("DFDD5007", &tmppath);
+	LOG_TEST_RET(card->ctx, sc_select_file(card, &tmppath, NULL), "SELECT docnr");
+	r = sc_read_binary(card, 0, buff, buflen, 0);
+	if (r < 0) {
+		free(buff);
+		LOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_CARD);
+	}
+	LOG_TEST_RET(card->ctx, r, "read document number failed");
+
+	for (j = 0; j < buflen; j++) {
+		if (!isalnum(buff[j])) {
+			free(buff);
+			LOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_CARD);
+		}
+	}
+	buff[buflen] = '\0';
+
+	free(p15card->tokeninfo->serial_number);
+	p15card->tokeninfo->serial_number = (char *)buff;
+	p15card->tokeninfo->flags = SC_PKCS15_TOKEN_READONLY;
+
+	/* add certificates */
+	for (i = 0; i < 2; i++) {
+		static const char *cert_names[2] = {"Isikutuvastus", "Allkirjastamine"};
+		static const char *cert_paths[2] = {"ADF1:3411", "ADF2:3421"};
+
+		struct sc_pkcs15_cert_info cert_info = {
+				.id = {.len = 1, .value[0] = prkey_id[i]}
+		 };
+		struct sc_pkcs15_object cert_obj = {0};
+
+		strlcpy(cert_obj.label, cert_names[i], sizeof(cert_obj.label));
+		sc_format_path(cert_paths[i], &cert_info.path);
+		r = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);
+		LOG_TEST_GOTO_ERR(card->ctx, r, "Could not add cert object");
+
+		if (i != 0)
+			continue;
+
+		sc_pkcs15_cert_t *cert = NULL;
+		r = sc_pkcs15_read_certificate(p15card, &cert_info, 0, &cert);
+		LOG_TEST_GOTO_ERR(card->ctx, r, "Could not read authentication certificate");
+
+		if (cert->key->algorithm == SC_ALGORITHM_EC)
+			field_length = cert->key->u.ec.params.field_length;
+
+		static const struct sc_object_id cn_oid = {
+				{2, 5, 4, 3, -1}
+		};
+		u8 *cn_name = NULL;
+		size_t cn_len = 0;
+		r = sc_pkcs15_get_name_from_dn(card->ctx, cert->subject, cert->subject_len, &cn_oid, &cn_name, &cn_len);
+		sc_pkcs15_free_certificate(cert);
+		LOG_TEST_GOTO_ERR(card->ctx, r, "Could not read authentication certificate");
+		if (cn_len > 0) {
+			char *token_name = (char *)realloc(cn_name, cn_len + 1);
+			if (token_name) {
+				token_name[cn_len] = '\0';
+				free(p15card->tokeninfo->label);
+				p15card->tokeninfo->label = token_name;
+			} else
+				free(cn_name);
+		}
+	}
+
+	/* add pins */
+	for (i = 0; i < 3; i++) {
+		static const char *pin_names[3] = {"PIN1", "PIN2", "PUK"};
+		static const size_t pin_min[3] = {4, 5, 8};
+		static const int pin_ref[3] = {0x81, 0x82, 0x83};
+		static const u8 pin_authid[3] = {1, 2, 3};
+
+		static const unsigned int pin_flags[3] = {
+				SC_PKCS15_PIN_FLAG_NEEDS_PADDING | SC_PKCS15_PIN_FLAG_INITIALIZED | SC_PKCS15_PIN_FLAG_LOCAL,
+				SC_PKCS15_PIN_FLAG_NEEDS_PADDING | SC_PKCS15_PIN_FLAG_INITIALIZED | SC_PKCS15_PIN_FLAG_LOCAL,
+				SC_PKCS15_PIN_FLAG_NEEDS_PADDING | SC_PKCS15_PIN_FLAG_INITIALIZED | SC_PKCS15_PIN_FLAG_LOCAL | SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN};
+
+		struct sc_pkcs15_auth_info pin_info = {
+				.auth_id = {.len = 1, .value[0] = pin_authid[i]},
+				.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN,
+				.attrs = {
+						.pin = {
+								.reference = pin_ref[i],
+								.flags = pin_flags[i],
+								.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC,
+								.min_length = pin_min[i],
+								.stored_length = 12,
+								.max_length = 12,
+								.pad_char = 0x00}},
+				.tries_left = 3,
+				.max_tries = 3
+		      };
+		struct sc_pkcs15_object pin_obj = {.flags = pin_flags[i]};
+
+		strlcpy(pin_obj.label, pin_names[i], sizeof(pin_obj.label));
+
+		/* Link normal PINs with PUK */
+		if (i < 2) {
+			pin_obj.auth_id.len = 1;
+			pin_obj.auth_id.value[0] = 3;
+		}
+
+		r = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);
+		LOG_TEST_GOTO_ERR(card->ctx, r, "Could not add pin object");
+	}
+
+	// trigger PIN counter refresh via pin_cmd
+	struct sc_pkcs15_object *objs[3];
+	r = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH, objs, 3);
+	if (r != 3) {
+		sc_log(card->ctx, "Can not get auth objects");
+		goto err;
+	}
+	for (i = 0; i < r; i++) {
+		r = sc_pkcs15_get_pin_info(p15card, objs[i]);
+		LOG_TEST_GOTO_ERR(card->ctx, r, "Could not get pin object");
+	}
+
+	/* add private keys */
+	for (i = 0; i < 2; i++) {
+		static const u8 prkey_ref[2] = {0x01, 0x05};
+		static const u8 prkey_pin[2] = {1, 2};
+		static const char *prkey_name[2] = {"Isikutuvastus", "Allkirjastamine"};
+		static const unsigned int prkey_usage[2] = {SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE,
+				SC_PKCS15_PRKEY_USAGE_NONREPUDIATION};
+		static const int prkey_consent[2] = {0, 1};
+
+		struct sc_pkcs15_prkey_info prkey_info = {
+				.id = {.len = 1, .value[0] = prkey_id[i]},
+				.native = 1,
+				.key_reference = prkey_ref[i],
+				.field_length = field_length,
+				.usage = prkey_usage[i]
+		       };
+		struct sc_pkcs15_object prkey_obj = {
+				.auth_id = {.len = 1, .value[0] = prkey_pin[i]},
+				.user_consent = prkey_consent[i],
+				.flags = SC_PKCS15_CO_FLAG_PRIVATE
+		  };
+
+		strlcpy(prkey_obj.label, prkey_name[i], sizeof(prkey_obj.label));
+
+		r = sc_pkcs15emu_add_ec_prkey(p15card, &prkey_obj, &prkey_info);
+		LOG_TEST_GOTO_ERR(card->ctx, r, "Could not add private key object");
+	}
+
+	return SC_SUCCESS;
+err:
+	sc_pkcs15_card_clear(p15card);
+	LOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);
+}
+
+int
+sc_pkcs15emu_esteid2025_init_ex(sc_pkcs15_card_t *p15card, struct sc_aid *aid)
+{
+	if (p15card->card->type == SC_CARD_TYPE_ESTEID_2025)
+		return sc_pkcs15emu_esteid2025_init(p15card);
+	return SC_ERROR_WRONG_CARD;
+}
Index: opensc-0.26.1/src/libopensc/pkcs15-syn.c
===================================================================
--- opensc-0.26.1.orig/src/libopensc/pkcs15-syn.c
+++ opensc-0.26.1/src/libopensc/pkcs15-syn.c
@@ -56,6 +56,7 @@ struct sc_pkcs15_emulator_handler builti
 	{ "coolkey",    sc_pkcs15emu_coolkey_init_ex	},
 	{ "din66291",   sc_pkcs15emu_din_66291_init_ex	},
 	{ "esteid2018", sc_pkcs15emu_esteid2018_init_ex	},
+	{ "esteid2025", sc_pkcs15emu_esteid2025_init_ex	},
 	{ "skeid",      sc_pkcs15emu_skeid_init_ex      },
 	{ "cardos",     sc_pkcs15emu_cardos_init_ex	},
 	{ "nqapplet",   sc_pkcs15emu_nqapplet_init_ex },
Index: opensc-0.26.1/src/libopensc/pkcs15-syn.h
===================================================================
--- opensc-0.26.1.orig/src/libopensc/pkcs15-syn.h
+++ opensc-0.26.1/src/libopensc/pkcs15-syn.h
@@ -33,6 +33,7 @@ int sc_pkcs15emu_openpgp_init_ex(sc_pkcs
 int sc_pkcs15emu_starcert_init_ex(sc_pkcs15_card_t *,	struct sc_aid *);
 int sc_pkcs15emu_tcos_init_ex(sc_pkcs15_card_t *,	struct sc_aid *);
 int sc_pkcs15emu_esteid2018_init_ex(sc_pkcs15_card_t *,	struct sc_aid *);
+int sc_pkcs15emu_esteid2025_init_ex(sc_pkcs15_card_t *, struct sc_aid *);
 int sc_pkcs15emu_piv_init_ex(sc_pkcs15_card_t *p15card,	struct sc_aid *);
 int sc_pkcs15emu_cac_init_ex(sc_pkcs15_card_t *p15card,	struct sc_aid *);
 int sc_pkcs15emu_gemsafeV1_init_ex(sc_pkcs15_card_t *p15card,	struct sc_aid *);
Index: opensc-0.26.1/src/libopensc/pkcs15.c
===================================================================
--- opensc-0.26.1.orig/src/libopensc/pkcs15.c
+++ opensc-0.26.1/src/libopensc/pkcs15.c
@@ -1235,6 +1235,7 @@ const char *pkcs15_get_default_use_file_
 		"dnie",
 		"edo",
 		"esteid2018",
+		"esteid2025",
 		"flex",
 		"cyberflex",
 		"gemsafeV1",
