From 1850883f18beaf147311542f53f75e5c51fb1350 Mon Sep 17 00:00:00 2001
From: Raul Metsma <raul@metsma.ee>
Date: Tue, 15 Apr 2025 09:03:25 +0300
Subject: [PATCH] EstEID 2018 v2

new ATR + code cleanup

Signed-off-by: Raul Metsma <raul@metsma.ee>
---
 src/libopensc/card-esteid2018.c   | 155 ++++++++++++------------------
 src/libopensc/pkcs15-esteid2018.c | 138 +++++++++++++-------------
 2 files changed, 129 insertions(+), 164 deletions(-)

Index: opensc-0.26.1/src/libopensc/card-esteid2018.c
===================================================================
--- opensc-0.26.1.orig/src/libopensc/card-esteid2018.c
+++ opensc-0.26.1/src/libopensc/card-esteid2018.c
@@ -32,18 +32,32 @@
 
 /* Helping defines */
 #define SIGNATURE_PAYLOAD_SIZE 0x30
-#define PIN1_REF 0x01
-#define PIN2_REF 0x85
-#define PUK_REF 0x02
+#define AUTH_REF	       0x81
+#define SIGN_REF	       0x9f
+#define PIN1_REF	       0x01
+#define PIN2_REF	       0x85
+#define PUK_REF		       0x02
 
 static const struct sc_atr_table esteid_atrs[] = {
-    {"3b:db:96:00:80:b1:fe:45:1f:83:00:12:23:3f:53:65:49:44:0f:90:00:f1", NULL, "EstEID 2018", SC_CARD_TYPE_ESTEID_2018, 0, NULL},
-    {NULL, NULL, NULL, 0, 0, NULL}};
+		{"3b:db:96:00:80:b1:fe:45:1f:83:00:12:23:3f:53:65:49:44:0f:90:00:f1",    NULL, "EstEID 2018", SC_CARD_TYPE_ESTEID_2018, 0, NULL},
+		{"3b:dc:96:00:80:b1:fe:45:1f:83:00:12:23:3f:54:65:49:44:32:0f:90:00:c3", NULL, "EstEID 2018 v2", SC_CARD_TYPE_ESTEID_2018_V2, 0, NULL},
+		{NULL,								   NULL, NULL,	   0,			      0, NULL}
+};
 
-static const struct sc_aid IASECC_AID = {{0xA0, 0x00, 0x00, 0x00, 0x77, 0x01, 0x08, 0x00, 0x07, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x01, 0x00},
-                                         16};
+static const struct sc_aid IASECC_AID = {
+		{0xA0, 0x00, 0x00, 0x00, 0x77, 0x01, 0x08, 0x00, 0x07, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x01, 0x00},
+		16
+};
 
-static const struct sc_path adf2 = {{0x3f, 0x00, 0xAD, 0xF2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 4, 0, 0, SC_PATH_TYPE_PATH, {{0}, 0}};
+static const struct sc_path MF = {
+		{0x3f, 0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		2, 0, 0, SC_PATH_TYPE_PATH, {{0}, 0}
+};
+
+static const struct sc_path adf2 = {
+		{0x3f, 0x00, 0xAD, 0xF2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+		4, 0, 0, SC_PATH_TYPE_PATH, {{0}, 0}
+};
 
 static const struct sc_card_operations *iso_ops = NULL;
 static struct sc_card_operations esteid_ops;
@@ -56,10 +70,10 @@ struct esteid_priv_data {
 
 #define DRVDATA(card) ((struct esteid_priv_data *)((card)->drv_data))
 
-#define SC_TRANSMIT_TEST_RET(card, apdu, text)                                                                                                      \
-	do {                                                                                                                               \
-		LOG_TEST_RET(card->ctx, sc_transmit_apdu(card, &apdu), "APDU transmit failed");                                            \
-		LOG_TEST_RET(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2), text);                                                      \
+#define SC_TRANSMIT_TEST_RET(card, apdu, text) \
+	do { \
+		LOG_TEST_RET(card->ctx, sc_transmit_apdu(card, &apdu), "APDU transmit failed"); \
+		LOG_TEST_RET(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2), text); \
 	} while (0)
 
 static int esteid_match_card(sc_card_t *card) {
@@ -72,40 +86,13 @@ static int esteid_match_card(sc_card_t *
 	return 0;
 }
 
-static int esteid_check_sw(sc_card_t *card, unsigned int sw1, unsigned int sw2) {
-	if (sw1 == 0x6B && sw2 == 0x00)
-		LOG_FUNC_RETURN(card->ctx, SC_ERROR_FILE_END_REACHED);
-	return iso_ops->check_sw(card, sw1, sw2);
-}
-
-static int esteid_select(struct sc_card *card, unsigned char p1, unsigned char id1, unsigned char id2) {
-	struct sc_apdu apdu;
-	unsigned char sbuf[2];
-
-	LOG_FUNC_CALLED(card->ctx);
-
-	// Select EF/DF
-	sbuf[0] = id1;
-	sbuf[1] = id2;
-
-	sc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0xA4, p1, 0x0C);
-	if (id1 != 0x3F && id2 != 0x00) {
-		apdu.cse = SC_APDU_CASE_3_SHORT;
-		apdu.lc = 2;
-		apdu.data = sbuf;
-		apdu.datalen = 2;
-	}
-	apdu.le = 0;
-	apdu.resplen = 0;
-
-	SC_TRANSMIT_TEST_RET(card, apdu, "SELECT failed");
-	LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);
-}
-
 static int esteid_select_file(struct sc_card *card, const struct sc_path *in_path, struct sc_file **file_out) {
-	unsigned char pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;
-	size_t pathlen;
+	const u8 *path = in_path->value;
+	u8 resp[SC_MAX_APDU_RESP_SIZE];
+	size_t resplen = sizeof(resp);
+	int r;
 	struct sc_file *file = NULL;
+	struct sc_apdu apdu;
 
 	LOG_FUNC_CALLED(card->ctx);
 
@@ -113,54 +100,45 @@ static int esteid_select_file(struct sc_
 	if (in_path->type != SC_PATH_TYPE_PATH) {
 		LOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);
 	}
+	if (in_path->len % 2 != 0) {
+		LOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);
+	}
 
-	memcpy(path, in_path->value, in_path->len);
-	pathlen = in_path->len;
-
-	while (pathlen >= 2) {
+	for (size_t pathlen = in_path->len; pathlen >= 2; pathlen -= 2, path += 2) {
 		if (memcmp(path, "\x3F\x00", 2) == 0) {
-			LOG_TEST_RET(card->ctx, esteid_select(card, 0x00, 0x3F, 0x00), "MF select failed");
-		} else if (path[0] == 0xAD) {
-			LOG_TEST_RET(card->ctx, esteid_select(card, 0x01, path[0], path[1]), "DF select failed");
-		} else if (pathlen == 2) {
-			LOG_TEST_RET(card->ctx, esteid_select(card, 0x02, path[0], path[1]), "EF select failed");
+			sc_format_apdu_ex(&apdu, card->cla, 0xA4, 0x00, 0x0C, path, 0, NULL, 0);
+			SC_TRANSMIT_TEST_RET(card, apdu, "MF select failed");
+		} else if (pathlen == 2 && path[0] == 0xAD) {
+			sc_format_apdu_ex(&apdu, card->cla, 0xA4, 0x01, 0x0C, path, 2, NULL, 0);
+			SC_TRANSMIT_TEST_RET(card, apdu, "DF select failed");
+		} else {
+			sc_format_apdu_ex(&apdu, card->cla, 0xA4, 0x09, 0x04, path, pathlen, resp, resplen);
+			SC_TRANSMIT_TEST_RET(card, apdu, "EF select failed");
 
-			if (file_out != NULL) // Just make a dummy file
-			{
+			if (file_out != NULL) {
 				file = sc_file_new();
 				if (file == NULL)
 					LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
-				file->path = *in_path;
-				file->size = 1536; // Dummy size, to be above 1024
-
+				r = iso_ops->process_fci(card, file, resp, resplen);
+				if (r != SC_SUCCESS) {
+					sc_file_free(file);
+				}
+				LOG_TEST_RET(card->ctx, r, "Process fci failed");
 				*file_out = file;
 			}
+			break;
 		}
-		path += 2;
-		pathlen -= 2;
 	}
 	LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);
 }
 
-// temporary hack, overload 6B00 SW processing
-static int esteid_read_binary(struct sc_card *card, unsigned int idx, u8 *buf, size_t count, unsigned long *flags) {
-	int r;
-	int (*saved)(struct sc_card *, unsigned int, unsigned int) = card->ops->check_sw;
-	LOG_FUNC_CALLED(card->ctx);
-	card->ops->check_sw = esteid_check_sw;
-	r = iso_ops->read_binary(card, idx, buf, count, flags);
-	card->ops->check_sw = saved;
-	LOG_FUNC_RETURN(card->ctx, r);
-}
-
 static int esteid_set_security_env(sc_card_t *card, const sc_security_env_t *env, int se_num) {
 	struct esteid_priv_data *priv;
 	struct sc_apdu apdu;
 
-	// XXX: could be const
-	unsigned char cse_crt_aut[] = {0x80, 0x04, 0xFF, 0x20, 0x08, 0x00, 0x84, 0x01, 0x81};
-	unsigned char cse_crt_sig[] = {0x80, 0x04, 0xFF, 0x15, 0x08, 0x00, 0x84, 0x01, 0x9F};
-	unsigned char cse_crt_dec[] = {0x80, 0x04, 0xFF, 0x30, 0x04, 0x00, 0x84, 0x01, 0x81};
+	static const u8 cse_crt_aut[] = {0x80, 0x04, 0xFF, 0x20, 0x08, 0x00, 0x84, 0x01, AUTH_REF};
+	static const u8 cse_crt_sig[] = {0x80, 0x04, 0xFF, 0x15, 0x08, 0x00, 0x84, 0x01, SIGN_REF};
+	static const u8 cse_crt_dec[] = {0x80, 0x04, 0xFF, 0x30, 0x04, 0x00, 0x84, 0x01, AUTH_REF};
 
 	LOG_FUNC_CALLED(card->ctx);
 
@@ -169,11 +147,11 @@ static int esteid_set_security_env(sc_ca
 
 	sc_log(card->ctx, "algo: %lu operation: %d keyref: %d", env->algorithm, env->operation, env->key_ref[0]);
 
-	if (env->algorithm == SC_ALGORITHM_EC && env->operation == SC_SEC_OPERATION_SIGN && env->key_ref[0] == 1) {
+	if (env->algorithm == SC_ALGORITHM_EC && env->operation == SC_SEC_OPERATION_SIGN && env->key_ref[0] == AUTH_REF) {
 		sc_format_apdu_ex(&apdu, 0x00, 0x22, 0x41, 0xA4, cse_crt_aut, sizeof(cse_crt_aut), NULL, 0);
-	} else if (env->algorithm == SC_ALGORITHM_EC && env->operation == SC_SEC_OPERATION_SIGN && env->key_ref[0] == 2) {
+	} else if (env->algorithm == SC_ALGORITHM_EC && env->operation == SC_SEC_OPERATION_SIGN && env->key_ref[0] == SIGN_REF) {
 		sc_format_apdu_ex(&apdu, 0x00, 0x22, 0x41, 0xB6, cse_crt_sig, sizeof(cse_crt_sig), NULL, 0);
-	} else if (env->algorithm == SC_ALGORITHM_EC && env->operation == SC_SEC_OPERATION_DERIVE && env->key_ref[0] == 1) {
+	} else if (env->algorithm == SC_ALGORITHM_EC && env->operation == SC_SEC_OPERATION_DERIVE && env->key_ref[0] == AUTH_REF) {
 		sc_format_apdu_ex(&apdu, 0x00, 0x22, 0x41, 0xB8, cse_crt_dec, sizeof(cse_crt_dec), NULL, 0);
 	} else {
 		LOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);
@@ -189,7 +167,7 @@ static int esteid_compute_signature(sc_c
 	struct esteid_priv_data *priv = DRVDATA(card);
 	struct sc_security_env *env = NULL;
 	struct sc_apdu apdu;
-	u8 sbuf[SIGNATURE_PAYLOAD_SIZE];
+	u8 sbuf[SIGNATURE_PAYLOAD_SIZE] = {0};
 	size_t le = MIN(SC_MAX_APDU_RESP_SIZE, MIN(SIGNATURE_PAYLOAD_SIZE * 2, outlen));
 
 	LOG_FUNC_CALLED(card->ctx);
@@ -199,11 +177,10 @@ static int esteid_compute_signature(sc_c
 	env = &priv->sec_env;
 	// left-pad if necessary
 	memcpy(&sbuf[SIGNATURE_PAYLOAD_SIZE - datalen], data, MIN(datalen, SIGNATURE_PAYLOAD_SIZE));
-	memset(sbuf, 0x00, SIGNATURE_PAYLOAD_SIZE - datalen);
 	datalen = SIGNATURE_PAYLOAD_SIZE;
 
 	switch (env->key_ref[0]) {
-	case 1: /* authentication key */
+	case AUTH_REF:
 		sc_format_apdu_ex(&apdu, 0x00, 0x88, 0, 0, sbuf, datalen, out, le);
 		break;
 	default:
@@ -216,22 +193,20 @@ static int esteid_compute_signature(sc_c
 }
 
 static int esteid_get_pin_remaining_tries(sc_card_t *card, int pin_reference) {
-	unsigned char get_pin_info[] = {0x4D, 0x08, 0x70, 0x06, 0xBF, 0x81, 0xFF, 0x02, 0xA0, 0x80};
-
+	const u8 get_pin_info[] = {0x4D, 0x08, 0x70, 0x06, 0xBF, 0x81, pin_reference & 0x0F, 0x02, 0xA0, 0x80}; // mask out local/global
 	struct sc_apdu apdu;
-	unsigned char apdu_resp[SC_MAX_APDU_RESP_SIZE];
+	u8 apdu_resp[SC_MAX_APDU_RESP_SIZE];
 	LOG_FUNC_CALLED(card->ctx);
 
 	// We don't get the file information here, so we need to be ugly
 	if (pin_reference == PIN1_REF || pin_reference == PUK_REF) {
-		LOG_TEST_RET(card->ctx, esteid_select(card, 0x00, 0x3F, 0x00), "Cannot select MF");
+		LOG_TEST_RET(card->ctx, esteid_select_file(card, &MF, NULL), "Cannot select MF");
 	} else if (pin_reference == PIN2_REF) {
 		LOG_TEST_RET(card->ctx, esteid_select_file(card, &adf2, NULL), "Cannot select QSCD AID");
 	} else {
 		LOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);
 	}
 
-	get_pin_info[6] = pin_reference & 0x0F; // mask out local/global
 	sc_format_apdu_ex(&apdu, 0x00, 0xCB, 0x3F, 0xFF, get_pin_info, sizeof(get_pin_info), apdu_resp, sizeof(apdu_resp));
 	SC_TRANSMIT_TEST_RET(card, apdu, "GET DATA(pin info) failed");
 	if (apdu.resplen < 32) {
@@ -260,14 +235,14 @@ static int esteid_pin_cmd(sc_card_t *car
 	} else if (data->cmd == SC_PIN_CMD_UNBLOCK) {
 		// Verify PUK, then issue UNBLOCK
 		// VERIFY
-		memcpy(&tmp, data, sizeof(struct sc_pin_cmd_data));
+		tmp = *data;
 		tmp.cmd = SC_PIN_CMD_VERIFY;
 		tmp.pin_reference = PUK_REF;
 		tmp.pin2.len = 0;
 		r = iso_ops->pin_cmd(card, &tmp, tries_left);
 		LOG_TEST_RET(card->ctx, r, "VERIFY during unblock failed");
 
-		if (data->pin_reference == 0x85) {
+		if (data->pin_reference == PIN2_REF) {
 			LOG_TEST_RET(card->ctx, esteid_select_file(card, &adf2, NULL), "Cannot select QSCD AID");
 		}
 		// UNBLOCK
@@ -266,6 +266,9 @@ static int esteid_init(sc_card_t *card)
 		LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
 	card->drv_data = priv;
 	card->max_recv_size = 233; // XXX: empirical, not documented
+	if (card->type == SC_CARD_TYPE_ESTEID_2018_V2) {
+		card->max_recv_size = 0xC0; // Fix reading with some readers: Alcor Micro AU9540
+	}
 
 	flags = SC_ALGORITHM_ECDSA_RAW | SC_ALGORITHM_ECDH_CDH_RAW | SC_ALGORITHM_ECDSA_HASH_NONE;
 	ext_flags = SC_ALGORITHM_EXT_EC_NAMEDCURVE | SC_ALGORITHM_EXT_EC_UNCOMPRESES;
@@ -322,7 +296,6 @@ struct sc_card_driver *sc_get_esteid2018
 	esteid_ops.finish = esteid_finish;
 
 	esteid_ops.select_file = esteid_select_file;
-	esteid_ops.read_binary = esteid_read_binary;
 
 	esteid_ops.set_security_env = esteid_set_security_env;
 	esteid_ops.compute_signature = esteid_compute_signature;
Index: opensc-0.26.1/src/libopensc/pkcs15-esteid2018.c
===================================================================
--- opensc-0.26.1.orig/src/libopensc/pkcs15-esteid2018.c
+++ opensc-0.26.1/src/libopensc/pkcs15-esteid2018.c
@@ -48,7 +48,7 @@ static int sc_pkcs15emu_esteid2018_init(
 	LOG_TEST_RET(card->ctx, sc_select_file(card, &tmppath, NULL), "SELECT docnr");
 	r = sc_read_binary(card, 0, buff, 11, 0);
 	LOG_TEST_RET(card->ctx, r, "read document number failed");
-	const unsigned char *tag = sc_asn1_find_tag(card->ctx, buff, (size_t)r, 0x04, &taglen);
+	const u8 *tag = sc_asn1_find_tag(card->ctx, buff, (size_t)r, 0x04, &taglen);
 	if (tag == NULL)
 		LOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);
 
@@ -65,20 +65,17 @@ static int sc_pkcs15emu_esteid2018_init(
 
 	/* add certificates */
 	for (i = 0; i < 2; i++) {
-		const char *esteid_cert_names[2] = {"Isikutuvastus", "Allkirjastamine"};
-		const char *esteid_cert_paths[2] = {"3f00:adf1:3401", "3f00:adf2:341f"};
-		const u8 esteid_cert_ids[2] = {1, 2};
-
-		struct sc_pkcs15_cert_info cert_info;
-		struct sc_pkcs15_object cert_obj;
-
-		memset(&cert_info, 0, sizeof(cert_info));
-		memset(&cert_obj, 0, sizeof(cert_obj));
+		static const char *esteid_cert_names[2] = {"Isikutuvastus", "Allkirjastamine"};
+		static const char *esteid_cert_paths[2] = {"3f00:adf1:3401", "3f00:adf2:341f"};
+		static const u8 esteid_cert_ids[2] = {1, 2};
+
+		struct sc_pkcs15_cert_info cert_info = {
+				.id = {.len = 1, .value[0] = esteid_cert_ids[i]}
+		};
+		struct sc_pkcs15_object cert_obj = {0};
 
 		strlcpy(cert_obj.label, esteid_cert_names[i], sizeof(cert_obj.label));
 		sc_format_path(esteid_cert_paths[i], &cert_info.path);
-		cert_info.id.value[0] = esteid_cert_ids[i];
-		cert_info.id.len = 1;
 		r = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);
 		LOG_TEST_GOTO_ERR(card->ctx, r, "Could not add cert oebjct");
 
@@ -93,58 +90,57 @@ static int sc_pkcs15emu_esteid2018_init(
 		if (cert->key->algorithm == SC_ALGORITHM_EC)
 			field_length = cert->key->u.ec.params.field_length;
 
-		const struct sc_object_id cn_oid = {{2, 5, 4, 3, -1}};
+		static const struct sc_object_id cn_oid = {
+				{2, 5, 4, 3, -1}
+		};
 		u8 *cn_name = NULL;
 		size_t cn_len = 0;
 		sc_pkcs15_get_name_from_dn(card->ctx, cert->subject, cert->subject_len, &cn_oid, &cn_name, &cn_len);
+		sc_pkcs15_free_certificate(cert);
 		if (cn_len > 0) {
-			char *token_name = malloc(cn_len + 1);
+			char *token_name = (char *)realloc(cn_name, cn_len + 1);
 			if (token_name) {
-				memcpy(token_name, cn_name, cn_len);
 				token_name[cn_len] = '\0';
-				set_string(&p15card->tokeninfo->label, (const char *)token_name);
-				free(token_name);
-			}
+				free(p15card->tokeninfo->label);
+				p15card->tokeninfo->label = token_name;
+			} else
+				free(cn_name);
 		}
-		free(cn_name);
-		sc_pkcs15_free_certificate(cert);
 	}
 
 	/* add pins */
 	for (i = 0; i < 3; i++) {
-		const char *esteid_pin_names[3] = {"PIN1", "PIN2", "PUK"};
-		const size_t esteid_pin_min[3] = {4, 5, 8};
-		const int esteid_pin_ref[3] = {0x01, 0x85, 0x02};
-		const u8 esteid_pin_authid[3] = {1, 2, 3};
-		const char *esteid_pin_path[3] = {"3F00", "3F00ADF2", "3F00"};
-
-		const unsigned int esteid_pin_flags[3] = {
-		    SC_PKCS15_PIN_FLAG_NEEDS_PADDING | SC_PKCS15_PIN_FLAG_INITIALIZED,
-		    SC_PKCS15_PIN_FLAG_NEEDS_PADDING | SC_PKCS15_PIN_FLAG_INITIALIZED | SC_PKCS15_PIN_FLAG_LOCAL,
-		    SC_PKCS15_PIN_FLAG_NEEDS_PADDING | SC_PKCS15_PIN_FLAG_INITIALIZED | SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN};
-
-		struct sc_pkcs15_auth_info pin_info;
-		struct sc_pkcs15_object pin_obj;
-
-		memset(&pin_info, 0, sizeof(pin_info));
-		memset(&pin_obj, 0, sizeof(pin_obj));
+		static const char *esteid_pin_names[3] = {"PIN1", "PIN2", "PUK"};
+		static const size_t esteid_pin_min[3] = {4, 5, 8};
+		static const int esteid_pin_ref[3] = {0x01, 0x85, 0x02};
+		static const u8 esteid_pin_authid[3] = {1, 2, 3};
+		static const char *esteid_pin_path[3] = {"3F00", "3F00ADF2", "3F00"};
+
+		static const unsigned int esteid_pin_flags[3] = {
+				SC_PKCS15_PIN_FLAG_NEEDS_PADDING | SC_PKCS15_PIN_FLAG_INITIALIZED,
+				SC_PKCS15_PIN_FLAG_NEEDS_PADDING | SC_PKCS15_PIN_FLAG_INITIALIZED | SC_PKCS15_PIN_FLAG_LOCAL,
+				SC_PKCS15_PIN_FLAG_NEEDS_PADDING | SC_PKCS15_PIN_FLAG_INITIALIZED | SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN};
+
+		struct sc_pkcs15_auth_info pin_info = {
+				.auth_id = {.len = 1, .value[0] = esteid_pin_authid[i]},
+				.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN,
+				.attrs = {
+						.pin = {
+								.reference = esteid_pin_ref[i],
+								.flags = esteid_pin_flags[i],
+								.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC,
+								.min_length = esteid_pin_min[i],
+								.stored_length = 12,
+								.max_length = 12,
+								.pad_char = 0xFF}},
+				.tries_left = 3,
+				.max_tries = 3
+		      };
+		struct sc_pkcs15_object pin_obj = {
+				.flags = esteid_pin_flags[i]};
 
 		sc_format_path(esteid_pin_path[i], &pin_info.path);
-		pin_info.auth_id.len = 1;
-		pin_info.auth_id.value[0] = esteid_pin_authid[i];
-		pin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;
-		pin_info.attrs.pin.reference = esteid_pin_ref[i];
-		pin_info.attrs.pin.flags = esteid_pin_flags[i];
-		pin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;
-		pin_info.attrs.pin.min_length = esteid_pin_min[i];
-		pin_info.attrs.pin.stored_length = 12;
-		pin_info.attrs.pin.max_length = 12;
-		pin_info.attrs.pin.pad_char = 0xFF;
-		pin_info.tries_left = 3;
-		pin_info.max_tries = 3;
-
 		strlcpy(pin_obj.label, esteid_pin_names[i], sizeof(pin_obj.label));
-		pin_obj.flags = esteid_pin_flags[i];
 
 		/* Link normal PINs with PUK */
 		if (i < 2) {
@@ -170,33 +166,29 @@ static int sc_pkcs15emu_esteid2018_init(
 
 	/* add private keys */
 	for (i = 0; i < 2; i++) {
-		const u8 prkey_pin[2] = {1, 2};
-
-		const char *prkey_name[2] = {"Isikutuvastus", "Allkirjastamine"};
-		const char *prkey_path[2] = {"3F00:ADF1", "3F00:ADF2"};
-		const unsigned int prkey_usage[2] = {SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE,
-		                                     SC_PKCS15_PRKEY_USAGE_NONREPUDIATION};
-		const int prkey_consent[2] = {0, 1};
-
-		struct sc_pkcs15_prkey_info prkey_info;
-		struct sc_pkcs15_object prkey_obj;
-
-		memset(&prkey_info, 0, sizeof(prkey_info));
-		memset(&prkey_obj, 0, sizeof(prkey_obj));
+		static const u8 prkey_pin[2] = {1, 2};
+		static const char *prkey_name[2] = {"Isikutuvastus", "Allkirjastamine"};
+		static const char *prkey_path[2] = {"3F00:ADF1", "3F00:ADF2"};
+		static const unsigned int prkey_usage[2] = {SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE,
+				SC_PKCS15_PRKEY_USAGE_NONREPUDIATION};
+		static const int prkey_consent[2] = {0, 1};
+		static const u8 esteid_prkey_id[2] = {0x81, 0x9F};
+
+		struct sc_pkcs15_prkey_info prkey_info = {
+				.id = {.len = 1, .value[0] = prkey_pin[i]},
+				.native = 1,
+				.key_reference = esteid_prkey_id[i],
+				.field_length = field_length,
+				.usage = prkey_usage[i]
+		       };
+		struct sc_pkcs15_object prkey_obj = {
+				.auth_id = {.len = 1, .value[0] = prkey_pin[i]},
+				.user_consent = prkey_consent[i],
+				.flags = SC_PKCS15_CO_FLAG_PRIVATE
+		  };
 
 		sc_format_path(prkey_path[i], &prkey_info.path);
-		prkey_info.id.len = 1;
-		prkey_info.id.value[0] = prkey_pin[i];
-		prkey_info.native = 1;
-		prkey_info.key_reference = i + 1;
-		prkey_info.field_length = field_length;
-		prkey_info.usage = prkey_usage[i];
-
 		strlcpy(prkey_obj.label, prkey_name[i], sizeof(prkey_obj.label));
-		prkey_obj.auth_id.len = 1;
-		prkey_obj.auth_id.value[0] = prkey_pin[i];
-		prkey_obj.user_consent = prkey_consent[i];
-		prkey_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;
 
 		r = sc_pkcs15emu_add_ec_prkey(p15card, &prkey_obj, &prkey_info);
 		LOG_TEST_GOTO_ERR(card->ctx, r, "Could not add private key object");
@@ -201,7 +201,8 @@ err:
 }
 
 int sc_pkcs15emu_esteid2018_init_ex(sc_pkcs15_card_t *p15card, struct sc_aid *aid) {
-	if (p15card->card->type == SC_CARD_TYPE_ESTEID_2018)
+	if (p15card->card->type == SC_CARD_TYPE_ESTEID_2018 ||
+		p15card->card->type == SC_CARD_TYPE_ESTEID_2018_V2)
 		return sc_pkcs15emu_esteid2018_init(p15card);
 	return SC_ERROR_WRONG_CARD;
 }
Index: opensc-0.26.1/src/libopensc/cards.h
===================================================================
--- opensc-0.26.1.orig/src/libopensc/cards.h
+++ opensc-0.26.1/src/libopensc/cards.h
@@ -231,6 +231,7 @@ enum {
 
 	/* EstEID cards */
 	SC_CARD_TYPE_ESTEID_2018 = 35000,
+	SC_CARD_TYPE_ESTEID_2018_V2,
 	SC_CARD_TYPE_ESTEID_2025,
 
 	/* Rutoken cards */
